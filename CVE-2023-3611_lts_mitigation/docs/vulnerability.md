Vulnerability Details
=====================

CVE-2023-3611: An out-of-bounds write vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation. The qfq_change_agg() function in net/sched/sch_qfq.c allows an out-of-bounds write because lmax is updated according to packet sizes without bounds checks.

This vulnerability affects the packet scheduler subsystem, specifically QFQ+.

An attacker can utilize this vulnerability to cause a slab-out-of-bounds read/write in the `kmalloc-8192` cache.

## Requirements

A user needs to be able to modify qdiscs, thus requiring `CAP_NET_ADMIN`.
Naturally this will be obtained through usernamespaces, thus one may require `CONFIG_USER_NS`.

The specific qdisc in question is QFQ, which needs to be enabled `CONFIG_NET_SCH_QFQ`.

## History

The fixing commit is https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3e337087c3b5805fe0b8a46ba622a962880b5d64
This is a fix for 462dbc9101ac ("pkt_sched: QFQ Plus: fair-queueing service at DRR cost") dating back to 2012.
Based on this I assume 3.0.x+ is affected.

## Triggering the Vulnerability

The issue is similar to CVE-2023-31436.

Consider the following code in `net/sched/sch_qfq.c`:

```c
static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch,
                struct sk_buff **to_free)
{
     unsigned int len = qdisc_pkt_len(skb), gso_segs;

    // ...

     if (unlikely(cl->agg->lmax < len)) {
         pr_debug("qfq: increasing maxpkt from %u to %u for class %u",
              cl->agg->lmax, len, cl->common.classid);
         err = qfq_change_agg(sch, cl, cl->agg->class_weight, len);
         if (err) {
             cl->qstats.drops++;
             return qdisc_drop(skb, sch, to_free);
         }

    // ...

     }
```

Here `lmax` is increased without any bounds checks according to the packet length `len`.
Usually this would not impose a problem because packet sizes are naturally limited.
This is however not the actual packet length, rather the `qdisc_pkt_len(skb)` which might apply size transformations according to `struct qdisc_size_table` as created by `qdisc_get_stab()` in `net/sched/sch_api.c` if the `TCA_STAB` option was set when modifying the qdisc.
A user may choose virtually any size using such a table.

`qfq_init_agg()` will then set `new_agg->lmax` accordingly.
Eventually `qfq_add_to_agg()` will initialize `new_agg->grp` when the call tree reaches `qfq_update_agg()`:

```c
// qfq_update_agg() in net/sched/sch_qfq.c
	agg->budgetmax = new_num_classes * agg->lmax;
	new_agg_weight = agg->class_weight * new_num_classes;
	agg->inv_w = ONE_FP/new_agg_weight;

	if (agg->grp == NULL) {
		int i = qfq_calc_index(agg->inv_w, agg->budgetmax,
				       q->min_slot_shift);
		agg->grp = &q->groups[i];
	}
```

`qfq_calc_index()` performs some simple arithmetics to choose the final value, but will not do any additional bounds checks. Eventually this results in `agg->grp` pointing out-of-bounds relative to the `q` object of type `struct qfq_sched` (in the kmalloc-8192 cache).

The group of the qfq_aggregate is used in several places, leading to OOB reads and writes.
