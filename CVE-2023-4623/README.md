**kernel version using** 
6.3 commit `457391b0380335d5e9a5babdec90ac53928b23b4`
config and bzImage are same as CVE-2024-41009.   

Affected: 2.6.3 ~ 6.5


## Overview

The vulnerability leads to a use-after-free on an `hfsc_class` object in `hfsc_dequeue()`. By replacing the vulnerable `hfsc_class` with a crafted `simple_xattr`, we can make `hfsc_dequeue()` perform a write-what-where. This is used to overwrite a function pointer in the kernel's `.data` section that is then called to execute a ROP chain and escape the namespace. The kernel base slide, which is needed to determine the write primitive's target address and ROP gadget addresses, is leaked using a prefetch timing side-channel.

## Setup

The exploit enters a network namespace as root in order to get `CAP_NET_ADMIN`:

```
unshare(CLONE_NEWUSER);
unshare(CLONE_NEWNET);
```
A temporary file is opened to attach attributes to for the `simple_xattr` spray:
```
xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0664);
```
If the kernel base is not provided, `kaslr_leak()` leaks it using a prefetch side-channel (see final section for details).

## Triggering the Vulnerability

To trigger the vulnerability, we need to set up an HFSC qdisc and send packets to it. We will need to open two types of sockets: an `AF_NETLINK` socket for configuring the qdisc and an `AF_INET` socket for enqueueing packets at the qdisc. The qdisc is set up on `lo` by sending preconstructed messages to the Netlink socket. The `tf_msg` struct is used to represent the Netlink route messages, which are constructed in `init_nl_msgs()`. The following sequence of messages is sent:

- `if_up_msg` sets `lo` up so that packets can be sent to the qdisc.
- `newqd_msg` attaches an HFSC qdisc to `lo`.
- `new_rsc_msg` adds a class with an RSC (real-time service curve) to the qdisc as a child of the root class.
- `new_fsc_msg` adds a class with an FSC (link-sharing service curve) to the qdisc as a child of the RSC class.
- At this point an `AF_INET` socket is opened and written to with `loopback_send()`. The message will be enqueued in the FSC class, causing the RSC class to be mistakenly added to the root class's `vt_tree`.
- `delc_msg` deletes the FSC class, then another `delc_msg` deletes the RSC class, leaving a dangling pointer to the underlying `hfsc_class` object in the root class's `vt_tree`.

## Write-What-Where

The use-after-free is reached via [`hfsc_dequeue()`](https://elixir.bootlin.com/linux/v6.1.36/source/net/sched/sch_hfsc.c#L1570 "https://elixir.bootlin.com/linux/v6.1.36/source/net/sched/sch_hfsc.c#L1570"), which calls `vttree_get_kminvt()`:

```
static struct hfsc_class *
vttree_get_minvt(struct hfsc_class *cl, u64 cur_time)
{
    /* if root-class's cfmin is bigger than cur_time nothing to do */
    if (cl->cl_cfmin > cur_time)
        return NULL;

    while (cl->level > 0) {
        cl = vttree_firstfit(cl, cur_time);
        if (cl == NULL)
            return NULL;
        /*
         * update parent's cl_cvtmin.
         */
        if (cl->cl_parent->cl_cvtmin < cl->cl_vt)
            cl->cl_parent->cl_cvtmin = cl->cl_vt;
    }
    return cl;
}
```

The loop will eventually assign our dangling pointer to `cl`. Then the line
```
cl->cl_parent->cl_cvtmin = cl->cl_vt;
```
gives us an 8-byte write-what-where primitive with the restriction that the value written is greater than what it is replacing. This primitive will be used to overwrite the `qfq_qdisc_ops.change()` function pointer in the kernel's `.data` section with a JOP gadget. Since the QFQ qdisc does not define a change function, `qfq_qdisc_ops.change()` is initially `NULL` and can be overwritten with any value.

A `simple_xattr` is used to store the target address and value. The exploit uses `spray_simple_xattrs()` to add attributes to a temporary file, which sprays the `kmalloc-1024` cache where the vulnerable `hfsc_class` is located with `simple_xattr` objects.

The `value` field of `simple_xattr` is filled with a fake `hfsc_class`. The following fields have to be faked:

- `cl_parent`: The address to write to minus `offsetof(hfsc_class, cl_cvtmin)`.  Set to the address of `qfq_qdisc_ops.change()`.
- `cl_vt`: The 8-byte value to write. Set to the address of a JOP gadget.
- `cl_f`: Set to zero to satisfy the `p->cl_f <= cur_time` condition in `vttree_firstfit()`.
- `level`: Set to a non-zero value to prevent `vttree_get_minvt()` from returning the dangling pointer and causing further use-after-frees.
- `vt_node`: This is the red-black tree node that the vulnerable class is accessed through. We make this a black node with `NULL` children to prevent crashes in `init_vf()` and `vttree_get_minvt()`.
- `vt_node.__rb_parent_color`: Set to 1, coloring the node black.
- `vt_node.rb_right`: Set to `NULL` so that it is not dereferenced.
- `vt_node.rb_left`: Set to `NULL` so that it is not dereferenced. 
- `cf_node`: There is another dangling pointer to the vulnerable class from root class's `cf_tree`. This is filled in the same way as `vt_node` to prevent a crash in `init_vf()` but is not otherwise relevant.

Once a `simple_xattr` has been allocated over the vulnerable `hfsc_class`, another FSC class is created with `new_fsc_msg` so that the qdisc has somewhere to enqueue packets (`hfsc_dequeue()` will return early if the qdisc is empty.) The write-what-where in `hfsc_dequeue()` is then triggered by sending an `AF_INET` packet with the `loopback_send()` helper function.

## modprobe_path
using this write-what-where primitive to change modprobe_path `/sbin/modprobe -> /tmp/zzzdprobe`. as `u64("/tmp/zzz") > u64("/sbin/mo")`   

## test

```
$ cat /flag
cat: /flag: Permission denied
$ whoami
test
$ ./poc 0xffffffff81000000
[*] Using provided kernel base: 0xffffffff81000000
[*] Triggered vulnerability
[*] Spraying simple_xattrs...
[*] Overwriting function pointer
[  102.402508] process 'poc' launched '/dev/fd/5' with NULL argv: empty string added
FLAG{test-by-hxqu}
/bin/sh: 0: can't access tty; job control turned off
# whoami
root
# cat /flag
FLAG{test-by-hxqu}
```
